npx create-react-app <name of project>
- creates a react project with the given name


npm start
- runs your project in localhost:3000

* to stop the server type "ctrl+c"


npm install
- install the modules/packages in package.json


* 
src/components/ExpenseItem.js:
function ExpenseItem() {
  return <h2>Expense item!</h2>;
}

export default ExpenseItem;

App.js:
import ExpenseItem from "./components/ExpenseItem";

function App() {
  return (
    <div>
      <h2>Let's get started!</h2>
      <p>This is also visible!</p>
      <ExpenseItem></ExpenseItem>
    </div>
  );
}

export default App;
** custom components start with an uppercase char


* to put your variables or just simple expression to JSX,
  use "{}" and put it in there
** works both in attributes and content of element


{props.children}
- including this to the wrapper/container component in the
  return statement as the content will enable using this
  component as a wrapper
* Card.js
import "./Card.css";

function Card(props) {
  return <div className="card">{props.children}</div>;
}

export default Card;


* to enable the assignment of a className attribute on a
  custom component, you must do the following:

import "./Card.css";

function Card(props) {
  const classes = "card " + props.className;
  return <div className={classes}>{props.children}</div>;
}

export default Card;

** the className indicated on the custom component will
   be put on props.className


import { useState } from 'react';
- a React Hook
- useState is a method in react dependency where you can
  re-execute the custom components that it is actually 
  included to apply the change you want to it if something 
  occurs
- can only be used inside React components directly (cannot
  be used in functions inside the React components)
* per component instance
- usage:
  const [<value>,<state updating function>] = useState(<original value>);
* value is the variable that can change value if state
  update function is called
* state updating function is the function that will change
  the value of value and actually re-executes the component
  where the useState is included to apply that change
* original value is the value that is used in initial call
  (transform)

* example of changing state because of a user event:
const ExpenseItem = (props) => {
  const [title, setTitle] = useState(props.title);

  const clickHandler = () => {
    setTitle("Updated!");
    console.log(title);
  };

  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">{props.amount}</div>
      </div>
      <button onClick={clickHandler}>Change Title</button>
    </Card>
  );
};
** state updating function result is scheduled and is not
   applied immediately and the console.log(title) will
   show the previous value


Listening to User Input
- use the onChange prop
* this not only can be used with inputs but also with
  dropdowns
* event object can also be accessed in React just like
  vanilla JS
* titleChangeHandler will be triggered by onChange prop:
const titleChangeHandler = (event) => {
  console.log(event.target.value);
};
** store it in useState rather than variable


Using One State Instead (And What's Better)
* When only using one useState(), instead storing a string 
  in useState() you store object "{}"
*
const [userInput, setUserInput] = useState({
  enteredTitle: "",
  enteredAmount: "",
  enteredDate: "",
});

const titleChangeHandler = (event) => {
  // setEnteredTitle(event.target.value);
  setUserInput({
    ...userInput,
    enteredTitle: event.target.value,
  });
};
** enteredTitle is reassigned while other keys is retained


Updating State That Depends On The Previous State
* whenever you update state and you depend on previous
  state, you should pass a function to the state updating
  function. This guarantees the latest state snapshot is
  used
*
setUserInput((prevState) => {
  return { ...prevState, enteredTitle: event.target.value };
});


Handling Form Submission
- use onSubmit prop on form element

event.preventDefault();
- prevents the normal flow of event such as form submission

*
const submitHandler = (event) => {
  event.preventDefault();

  const expenseData = {
    title: enteredTitle,
    amount: enteredAmount,
    date: new Date(enteredDate),
  };

  console.log(expenseData);
};


Child-to-Parent Component Communication (Bottom-Up)
* use a custom prop that will store the function pointer in
  order to be called inside the child component
**
NewExpense.js (parent):
import React from "react";

import ExpenseForm from "./ExpenseForm";
import "./NewExpense.css";

const NewExpense = () => {
  const saveExpenseDataHandler = (enteredExpenseData) => {
    const expenseData = {
      ...enteredExpenseData,
      id: Math.random().toString(),
    };
    console.log(expenseData);
  };

  return (
    <div className="new-expense">
      <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
    </div>
  );
};

export default NewExpense;

*** saveExpenseDataHandler function will be passed to the
    child component through the custom prop 
    onSaveExpenseData
*** the child component will call that function and put the
    value as an argument:
    (props.onSaveExpenseData(expenseData))

*** this will automatically be passed to the parent
    component

Lifting State Up
- passing the state from child to parent to be used in
  parent or by another child by passing it via props


Rendering Lists of Data
- access the props.expenses (name of prop) to get the array
- use .map() to apply things to each and every element in
  array
*
{props.expenses.map((expense) => (
  <ExpenseItem
    title={expense.title}
    amount={expense.amount}
    date={expense.date}
  />
))}


Outputting Conditional Content
- Conditional Content
-- rendering output based on a given condition


* using && and put the component to be rendered. If first
  condition is true, it will be rendered


Adding Dynamic Styles
*
import React from "react";

import "./ChartBar.css";

const ChartBar = (props) => {
  let barFillHeight = "0%";

  if (props.max > 0) {
    barFillHeight = Math.round((props.value / props.maxValue) * 100) + "%";
  }

  return (
    <div className="chart-bar">
      <div className="chart-bar__inner">
        <div
          className="chart-bar__fill"
          style={{ height: barFillHeight }}
        ></div>
      </div>
      <div className="chart-bar__label">{props.label}</div>
    </div>
  );
};

export default ChartBar;

** style attribute in JSX requires a JavaScript Object
   keys being the name of the style
** styles with "-" will be converted to camel casing


.trim()
- trims out blank characters
* can be used to check if input is just blank
** enteredValue.trim().length === 0


* when you want to set style based on condition, use
  ternary operator
** 
style={{ color: !isValid ? "red" : "black" }}


Setting CSS Classes Dynamically
* instead of using inline-styles, make css classes dynamic
- use template literal
*
<div className={`form-control ${!isValid ? "invalid" : ""}`}>


- Styled Components
-- 3rd party package
-- applies styles directly to components
-- https://styled-components.com/
-- creates dynamically unique generated classes that will
   wrap the styles that you have indicated in it

styled.button``
- tag template literal
- a special kind of function
*
const Button = styled.button``;

*
styled.button`
  font: inherit;
  padding: 0.5rem 1.5rem;
  border: 1px solid #8b005d;
  color: white;
  background: #8b005d;
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.26);
  cursor: pointer;

  &:focus {
    outline: none;
  }

  &:hover,
  &:active {
    background: #ac0e77;
    border-color: #ac0e77;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.26);
  }
`
** if styles is being applied to the element itself, no
   need for selector
** if using pseudo-element, or anything else that the 
   element itself is involved, replace element selector 
   with "&"

* you can use props in styled-components
**
border: 1px solid ${(props) => (props.invalid ? "red" : "#ccc")};

* you can use normal media query syntax in styled-components


CSS Modules
- only supported by projects that acually supports it
- https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/
- rename css file to <name>.module.css
- import it with your desired name
*
import styles from "./Button.module.css";

*
const Button = (props) => {
  return (
    <button type={props.type} className={styles.button} onClick={props.onClick}>
      {props.children}
    </button>
  );
};

*css modules creates unique class names

* for classes with "-", use bracket notation:
  styles["form-control"]

* if multiple classes:
<div
  className={`${styles["form-control"]} ${!isValid && styles.invalid}`}
>