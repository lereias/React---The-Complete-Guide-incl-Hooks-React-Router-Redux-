Module Introduction

User Interaction and State
- Making Apps Interactive and Reactive

- handling events
- updating the UI and working with "state"
- a closer look at components and state


Listening to Events and Working with Event Handlers
- create a button in ExpenseItem.js just right before Card
  ending tag


on<someevent>={<function to run>}
- prop/custom attribute
- a special prop that is used to listen to events
- instead of adding an eventListener like in vanilla JS to
  check the events that happens to the elements, In react
  we use this

*
In ExpenseItem.js function ExpenseItem:

const ExpenseItem = (props) => {
  const clickHandler = () => {
    console.log("Updated!!!!");
  };

  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">{props.amount}</div>
      </div>
      <button onClick={clickHandler}>Change Title</button>
    </Card>
  );
};


How Component Functions are Executed
* putting the prop value to a variable, using the variable
  instead of the prop value, and changing the value of
  variable when event occurs, will not change the value

* custom components are like function calls up until there
  is no more functions (components) left inside of it


Working with "State"

state
- not originally a React concept

* custom components are not called again after initial
  call (transformation) by default

import { useState } from 'react';
- a React Hook
- useState is a method in react dependency where you can
  re-execute the custom components that it is actually 
  included to apply the change you want to it if something 
  occurs
- can only be used inside React components directly (cannot
  be used in functions inside the React components)
* per component instance
- usage:
  const [<value>,<state updating function>] = useState(<original value>);
* value is the variable that can change value if state
  update function is called
* state updating function is the function that will change
  the value of value and actually re-executes the component
  where the useState is included to apply that change
* original value is the value that is used in initial call
  (transform)

* example of changing state because of a user event:
const ExpenseItem = (props) => {
  const [title, setTitle] = useState(props.title);

  const clickHandler = () => {
    setTitle("Updated!");
    console.log(title);
  };

  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">{props.amount}</div>
      </div>
      <button onClick={clickHandler}>Change Title</button>
    </Card>
  );
};
** state updating function result is scheduled and is not
   applied immediately and the console.log(title) will
   show the previous value


A closer look at the "useState" Hook

useState
* per component instance


Adding Form Inputs
- add NewExpense folder in components
- add the necessary files in there


Listening to User Input
- use the onChange prop
* this not only can be used with inputs but also with
  dropdowns
* event object can also be accessed in React just like
  vanilla JS
* titleChangeHandler will be triggered by onChange prop:
const titleChangeHandler = (event) => {
  console.log(event.target.value);
};
** store it in useState rather than variable


Working with multiple States
* useState() can be used more than once in one component
  and each of them are independent from each other


* event.target.value will always return a string


Using One State Instead (And What's Better)
* When only using one useState(), instead storing a string 
  in useState() you store object "{}"
*
const [userInput, setUserInput] = useState({
  enteredTitle: "",
  enteredAmount: "",
  enteredDate: "",
});

const titleChangeHandler = (event) => {
  // setEnteredTitle(event.target.value);
  setUserInput({
    ...userInput,
    enteredTitle: event.target.value,
  });
};
** enteredTitle is reassigned while other keys is retained


Updating State That Depends On The Previous State
* whenever you update state and you depend on previous
  state, you should pass a function to the state updating
  function. This guarantees the latest state snapshot is
  used
*
setUserInput((prevState) => {
  return { ...prevState, enteredTitle: event.target.value };
});


Handling Form Submission
- use onSubmit prop on form element

event.preventDefault();
- prevents the normal flow of event such as form submission

*
const submitHandler = (event) => {
  event.preventDefault();

  const expenseData = {
    title: enteredTitle,
    amount: enteredAmount,
    date: new Date(enteredDate),
  };

  console.log(expenseData);
};


Adding Two-way binding
- listening to event to change state and change the value
  in JSX based on the state


Child-to-Parent Component Communication (Bottom-Up)
* use a custom prop that will store the function pointer in
  order to be called inside the child component
**
NewExpense.js (parent):
import React from "react";

import ExpenseForm from "./ExpenseForm";
import "./NewExpense.css";

const NewExpense = () => {
  const saveExpenseDataHandler = (enteredExpenseData) => {
    const expenseData = {
      ...enteredExpenseData,
      id: Math.random().toString(),
    };
    console.log(expenseData);
  };

  return (
    <div className="new-expense">
      <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
    </div>
  );
};

export default NewExpense;

*** saveExpenseDataHandler function will be passed to the
    child component through the custom prop 
    onSaveExpenseData
*** the child component will call that function and put the
    value as an argument:
    (props.onSaveExpenseData(expenseData))

*** this will automatically be passed to the parent
    component


* props can only be passed with parent to direct child


Lifting State Up
- passing the state from child to parent to be used in
  parent or by another child by passing it via 
* communication can only be done from parent to child and
  child to parent


Controlled vs Uncontrolled Components

Controlled Components
- when a value used in a component is passed on to a parent
  component through props or a value is received from the 
  parent component


Presentational vs Stateful Components
* Stateless vs Stateful Components
* Dumb vs Smart Components
- Stateful Component
-- holds a state

- Presentational Component
-- does not have state
-- most components does not have states 